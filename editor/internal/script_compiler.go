package editor

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
	"time"
)

// ScriptCompiler handles compiling project scripts into usable modules
type ScriptCompiler struct {
	ProjectPath     string
	ScriptsDir      string
	OutputDir       string
	LastCompileTime time.Time
	CompiledScripts []string
	CompileErrors   []string
	IsCompiling     bool
}

var GlobalScriptCompiler *ScriptCompiler

// InitScriptCompiler initializes the script compiler for a project
func InitScriptCompiler(projectPath string) {
	GlobalScriptCompiler = &ScriptCompiler{
		ProjectPath: projectPath,
		ScriptsDir:  filepath.Join(projectPath, "resources", "scripts"),
		OutputDir:   filepath.Join(projectPath, "build", "scripts"),
	}

	// Ensure directories exist
	os.MkdirAll(GlobalScriptCompiler.ScriptsDir, 0755)
	os.MkdirAll(GlobalScriptCompiler.OutputDir, 0755)
}

// GetScriptFiles returns all .go files in the scripts directory
func (sc *ScriptCompiler) GetScriptFiles() ([]string, error) {
	var scripts []string

	entries, err := os.ReadDir(sc.ScriptsDir)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		if strings.HasSuffix(strings.ToLower(name), ".go") {
			scripts = append(scripts, filepath.Join(sc.ScriptsDir, name))
		}
	}

	return scripts, nil
}

// GenerateScriptBundle generates a Go file that registers all project scripts
func (sc *ScriptCompiler) GenerateScriptBundle() error {
	scripts, err := sc.GetScriptFiles()
	if err != nil {
		return fmt.Errorf("failed to get scripts: %v", err)
	}

	if len(scripts) == 0 {
		return nil
	}

	// Parse script files to extract script names
	scriptInfos := []ScriptInfo{}
	for _, scriptPath := range scripts {
		info, err := parseScriptFile(scriptPath)
		if err != nil {
			sc.CompileErrors = append(sc.CompileErrors, fmt.Sprintf("%s: %v", filepath.Base(scriptPath), err))
			continue
		}
		scriptInfos = append(scriptInfos, info)
	}

	// Generate the bundle file
	bundlePath := filepath.Join(sc.OutputDir, "scripts_bundle.go")
	return generateBundleFile(bundlePath, scriptInfos, sc.ScriptsDir)
}

// ScriptInfo holds information about a parsed script
type ScriptInfo struct {
	Name           string // Script struct name (e.g., "RotateScript")
	FileName       string // File name without extension
	FilePath       string // Full path to the script file
	HasStart       bool
	HasUpdate      bool
	HasFixedUpdate bool
}

// parseScriptFile extracts script information from a Go file
func parseScriptFile(path string) (ScriptInfo, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return ScriptInfo{}, err
	}

	info := ScriptInfo{
		FileName: strings.TrimSuffix(filepath.Base(path), ".go"),
		FilePath: path,
	}

	// Simple parsing - look for struct definitions that embed BaseComponent
	lines := strings.Split(string(content), "\n")
	inStruct := false
	structName := ""

	for _, line := range lines {
		line = strings.TrimSpace(line)

		// Look for "type XxxScript struct"
		if strings.HasPrefix(line, "type ") && strings.Contains(line, "struct") {
			parts := strings.Fields(line)
			if len(parts) >= 3 {
				structName = parts[1]
				inStruct = true
			}
		}

		// Check if struct embeds BaseComponent
		if inStruct && strings.Contains(line, "BaseComponent") {
			info.Name = structName
		}

		if inStruct && line == "}" {
			inStruct = false
		}

		// Check for lifecycle methods
		if strings.Contains(line, "func") && strings.Contains(line, "Start()") {
			info.HasStart = true
		}
		if strings.Contains(line, "func") && strings.Contains(line, "Update()") {
			info.HasUpdate = true
		}
		if strings.Contains(line, "func") && strings.Contains(line, "FixedUpdate()") {
			info.HasFixedUpdate = true
		}
	}

	if info.Name == "" {
		return info, fmt.Errorf("no script struct found")
	}

	return info, nil
}

// Bundle template for generating the scripts registration file
const bundleTemplate = `// Code generated by Gopher3D Script Compiler. DO NOT EDIT.
package scripts

import (
	"Gopher3D/internal/behaviour"
{{range .Scripts}}
	// Script: {{.Name}}
{{end}}
)

func init() {
	// Register all project scripts
{{range .Scripts}}
	behaviour.RegisterScript("{{.Name}}", func() behaviour.Component {
		return &{{.Name}}{}
	})
{{end}}
}

// Script implementations are in separate files in this package
`

func generateBundleFile(outputPath string, scripts []ScriptInfo, scriptsDir string) error {
	// Create output directory
	os.MkdirAll(filepath.Dir(outputPath), 0755)

	// Create the bundle file
	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	tmpl, err := template.New("bundle").Parse(bundleTemplate)
	if err != nil {
		return err
	}

	data := struct {
		Scripts []ScriptInfo
	}{
		Scripts: scripts,
	}

	return tmpl.Execute(f, data)
}

// CompileScripts validates the project scripts by checking syntax
func (sc *ScriptCompiler) CompileScripts() error {
	sc.IsCompiling = true
	sc.CompileErrors = nil
	defer func() { sc.IsCompiling = false }()

	logToConsole("Validating project scripts...", "info")

	scripts, err := sc.GetScriptFiles()
	if err != nil {
		return fmt.Errorf("failed to get scripts: %v", err)
	}

	if len(scripts) == 0 {
		logToConsole("No scripts found to validate", "info")
		return nil
	}

	validCount := 0
	for _, scriptPath := range scripts {
		scriptName := filepath.Base(scriptPath)

		// Read and do basic syntax check
		content, err := os.ReadFile(scriptPath)
		if err != nil {
			sc.CompileErrors = append(sc.CompileErrors, fmt.Sprintf("%s: cannot read file: %v", scriptName, err))
			continue
		}

		// Check for required elements
		contentStr := string(content)
		hasPackage := strings.Contains(contentStr, "package ")
		hasBaseComponent := strings.Contains(contentStr, "behaviour.BaseComponent")
		hasInit := strings.Contains(contentStr, "func init()")

		if !hasPackage {
			sc.CompileErrors = append(sc.CompileErrors, fmt.Sprintf("%s: missing package declaration", scriptName))
			continue
		}

		if !hasBaseComponent {
			sc.CompileErrors = append(sc.CompileErrors, fmt.Sprintf("%s: script must embed behaviour.BaseComponent", scriptName))
			continue
		}

		if !hasInit {
			sc.CompileErrors = append(sc.CompileErrors, fmt.Sprintf("%s: missing init() function to register script", scriptName))
			continue
		}

		validCount++
		logToConsole(fmt.Sprintf("  [OK] %s", scriptName), "info")
	}

	sc.LastCompileTime = time.Now()
	sc.CompiledScripts = scripts

	if len(sc.CompileErrors) > 0 {
		return fmt.Errorf("%d script(s) have errors", len(sc.CompileErrors))
	}

	logToConsole(fmt.Sprintf("All %d scripts validated successfully", validCount), "info")
	return nil
}

// ValidateScript checks if a script file is valid Go code
func (sc *ScriptCompiler) ValidateScript(scriptPath string) error {
	// Use go vet to validate
	cmd := exec.Command("go", "vet", scriptPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("validation failed: %s", output)
	}
	return nil
}

// CreateScriptTemplate creates a new script file from a template
func (sc *ScriptCompiler) CreateScriptTemplate(name string) (string, error) {
	// Ensure name is valid
	if name == "" {
		return "", fmt.Errorf("script name cannot be empty")
	}

	// Capitalize first letter for Go export
	scriptName := strings.Title(strings.TrimSuffix(name, "Script"))
	if !strings.HasSuffix(scriptName, "Script") {
		scriptName += "Script"
	}

	fileName := strings.ToLower(scriptName) + ".go"
	filePath := filepath.Join(sc.ScriptsDir, fileName)

	// Check if file already exists
	if _, err := os.Stat(filePath); err == nil {
		return "", fmt.Errorf("script %s already exists", fileName)
	}

	// Generate script content
	content := fmt.Sprintf(`package scripts

import (
	"Gopher3D/internal/behaviour"
	"github.com/go-gl/mathgl/mgl32"
)

// %s is a custom script component
type %s struct {
	behaviour.BaseComponent
	
	// Add your custom fields here
	Speed float32
}

func init() {
	behaviour.RegisterScript("%s", func() behaviour.Component {
		return &%s{Speed: 1.0}
	})
}

// Start is called once when the script is first activated
func (s *%s) Start() {
	// Initialize your script here
}

// Update is called every frame
func (s *%s) Update() {
	// Add your update logic here
	// Example: rotate the object
	// transform := s.GetGameObject().Transform
	// transform.Rotate(mgl32.Vec3{0, 1, 0}, mgl32.DegToRad(s.Speed * 0.016))
	_ = mgl32.Vec3{} // Placeholder to avoid unused import
}

// FixedUpdate is called at fixed time intervals (physics)
func (s *%s) FixedUpdate() {
	// Add your physics logic here
}
`, scriptName, scriptName, scriptName, scriptName, scriptName, scriptName, scriptName)

	// Write the file
	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return "", fmt.Errorf("failed to create script: %v", err)
	}

	logToConsole(fmt.Sprintf("Created new script: %s", fileName), "info")
	return filePath, nil
}

// GetGoVersion returns the installed Go version
func GetGoVersion() string {
	cmd := exec.Command("go", "version")
	output, err := cmd.Output()
	if err != nil {
		return "Go not found"
	}
	return strings.TrimSpace(string(output))
}

// IsGoInstalled checks if Go is available in PATH
func IsGoInstalled() bool {
	_, err := exec.LookPath("go")
	return err == nil
}

// GetPlatformInfo returns current platform info
func GetPlatformInfo() string {
	return fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH)
}
